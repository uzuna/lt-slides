## nodejsで使えるES6
2015/11/07 LTDD#20

---

### 自己紹介

|||
|:---|:---|
|名前|uzuna|
|仕事|製造系:製品解析|
|趣味|読書|
|twitter|@Uzundk|
|読書メーター|同上|

---

10月のお勧め図書

<img class="img" src="image/2015_11_book.jpg" width="120px">

* 最古の料理
* 発刊 2003年12月5日
* 著者 ジャン・ボテロ

--

食事はとても身近  
おそらく日本なら一日三食+お菓子の食事をしているぐらい

--

料理は高度な技術体系

周囲に存在する何が食べれるもので  
どのように調理すればおいしいのかという知識  
また加工する技術体系が必要である

--

現代ならかなり整った状態で材料が手に入るけど  
昔はどうだったのだろうか。

--

__もっとも古いレシピ:__

* 紀元前80-後40年ごろのローマ時代のレシピ
* 『アピキウスのレシピ帖』
* 4,5世紀ぐらいに再編纂。14世紀ごろに印刷で広まる
* 総集編で一人の著者ではないとの見解

--

__日本語訳は?__

日本語訳だけではなく作ってしまった人までいたようです   
[古代ローマ「アピキウスの料理書」の料理を作ってみた企画](http://www.geocities.co.jp/Technopolis/2736/folklore/api/api_tukutta.htm)  
(風見猫さん)

--

という状態だったのですが

さらに古いもの、ローマからさらに1600年さかのぼる  
メソポタミア時代のものが見つかりました。

アッシリア学の第一人者で料理愛好家の著者が  
その詳細を追うのが本書の中身。

--

イエール大学のバビロニア文書集のタブレットの中から  
3枚、350行からなる楔形文字タブレットが見つかり  
25のレシピと加工、下ごしらえ手順の解説が得られた

--

ここでレシピの例

--

__牡羊の煮込み__

>これにはほかの肉は必要ない。お前は水を用意する。  
そこに脂肪、[(欠損)]、  
十分な量のねなし葛、塩を適量、玉葱とサミドゥ、[(欠損)]

--

(続き)  
>コリアンダー、ポロネギとにんにくを加える。  
お前は胴張り大鍋をかまにかける。  
火から下ろした後、お前はキシンム(kisimmu)を砕いて入れる。  
これで供する準備は整った。

--

なんだか詩みたいですね。  

出汁のレシピ、36種の香辛料や香料もあり  
この時代から美食は追及されていた事が分かる。

何が言いたいかというと

--


>生きる糧が生をもたらす

おいしく食べよう

---

というわけで本題

---

__nodejsで使えるES6__

---

## ES6とは

--

#### ES6とは

* ES6->[ECMA International](http://www.ecma-international.org/)によるスクリプトの標準化規格
* 現行はES5

--

ところでES6ってECMA2015という呼び名になっているのですね  
年度ごとに標準化部分を確定させていくようです。

--

ES5との比較は以下がとても参考になります。
[ECMAScript比較](http://es6-features.org/#Constants)

いっぱいあるので、よく使いそうなものを紹介します

--

なお直近のnodejs

* version 5.0.0(先月はじめは4.1だったとゆーのに)

これに伴いV8が4.6.85になりました  
先月まで使えなかった`Spread operator`が使えます!

---

## BlockScope

--

#### BlockScope
従来`function(){}`の中のみローカルだったのが  
`let`定義によって`for`などのブロック内でもローカル変数に

--

### before

```javascript
var i = 20;
for(var i=0; i<2; ++i){
	console.log(i); // 0,1	
}
console.log(i); // 2
```

### after

```javascript
let i = 20;
for(let i=0; i<2; ++i){
	console.log(i); // 0,1		
}
console.log(i); // 20
```


---

## Class

--

#### Class
プロトタイプ拡張だけだったのが  
クラス構文で定義が可能になりました


--

### before

```javascript
function klass(){
	this.id = 0;
	EventEmitter.call(this); // super constructor
}
util.inherits(klass, EventEmitter);	// extend methods
klass.prototype.set = function(val){
	return this.id = val
}
```

### after

```javascript
class klass extends EventEmitter(){
	constructor(){
		super();	// super constructor
		this.id = 0;
	}
	set(val){
		return this.id = val
	}
}
```

---

## Arrow Function

--

#### Arrow Function

`function`を省略できるようになりました。  
`this`の示す先が変わるので注意

--

### before

```javascript
function(data){
	var self = this;
	data.map(function(d){
		self.push(d);
	})
}
```

### after

```javascript
function(data){
	data.map((d)=>{
		this.push(d);
	})
}
```

---

## Rest parameter / Spread call

--

#### Rest parameter / Spread call

引数を`...arg`とすることですべての引数を配列でうけとれる  
またCall時には展開される

--

### Rest

```
AAA("colA", "colB", "colC")

function AAA(...arg){
  console.log(Array.isArray(arg));  // true
  console.log(arg.join(","));       // "colA,colB,colC"
}
```

--

### Spread

```
sum([1,3,5])

function sum(a,b,c){
  console.log(a + b + c) // 9
}
```

--

配列の中でもつかえます

```
let ary = [...Array(100).keys()]
```


---

## Template strings

--

#### Template strings

バッククォートで囲んだ文字列が対象  
`${name}`と言う表記の物はブロック内の変数の値でリプレースする


--

### before

```javascript
var column = "*";
var db = "mydb";
var query = 'SELECT' + column + 'from' + db;
```

### after

```javascript
let column = "*";
let db = "mydb";
let query = `SELECT ${column} from ${db}`;
```

---

## Object.assign

--

#### Object.assign

ついにオブジェクトのマージができるようになった!  
シャローコピーも簡単に作れる。

```
var C = Object.assign(A,B);          // Merge
var Clone_B = Object.assign({},B);   // Copy
```


---

## Promise/Generator

--

#### Promise/Generator
コールバック地獄から同期非同期コードの共存(新たな混沌)へ  
説明仕切れないのでさらっと

--

### before

```javascript
function A(data, (err, dataA)=>{
	dataA = dataA.join(",")
	function B(dataA, (err, dataB)=>{
		function C(dataB, (err, result)=>{
			done(err, result);  //( >д<)ﾈｽﾄｶﾞﾌｶｲ
		})
	})
})
```

### after

```javascript
function*(){
	let dataA = yield A(data);
	dataA = dataA.join(",");
	let dataB = yield B(dataA);
	let result = yield C(dataB);
	return result;
}
```


---

オンラインエディタで試せます:  
[http://www.es6fiddle.net/](http://www.es6fiddle.net/)